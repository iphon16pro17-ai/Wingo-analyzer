<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>WINGO ULTRA LEVEL X v3.6 ‚Äî Bangla Number Prediction Mode</title>

<!-- Tesseract.js (client-side OCR) -->
<script src="https://unpkg.com/tesseract.js@2.1.5/dist/tesseract.min.js"></script>

<style>
:root{
  --bg:#071022; --panel:#0b2030; --accent:#18d3c6; --muted:#9fb7d6; --glass:rgba(255,255,255,0.03);
  --good:#34d399; --bad:#fb7185; --gold:#f6c85f;
}
html,body{height:100%;margin:0;font-family:"Noto Sans Bengali",Inter,system-ui;background:var(--bg);color:#e6f6ff}
.container{max-width:980px;margin:14px auto;padding:14px}
.header{display:flex;align-items:center;justify-content:space-between}
.title{font-size:18px;color:var(--accent);font-weight:700}
.subtitle{color:var(--muted);font-size:13px}
.grid{display:grid;grid-template-columns:1fr 420px;gap:12px;margin-top:12px}
@media(max-width:900px){.grid{grid-template-columns:1fr}}
.card{background:var(--panel);border-radius:10px;padding:12px;border:1px solid rgba(255,255,255,0.02)}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.input{width:100%;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);background:transparent;color:inherit}
.button{padding:10px 12px;border-radius:8px;border:none;background:var(--accent);color:#021024;cursor:pointer;font-weight:700}
.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted)}
.small{font-size:13px;color:var(--muted)}
.out{background:var(--glass);padding:10px;border-radius:8px;margin-top:8px;white-space:pre-wrap}
.mem{font-family:monospace;font-size:12px;white-space:pre-wrap;overflow:auto;max-height:260px;padding:10px;border-radius:8px;background:rgba(0,0,0,0.2)}
.stat{display:flex;justify-content:space-between;padding:8px;border-radius:6px;background:rgba(255,255,255,0.02);margin-top:8px}
.badge{padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.02);font-size:13px}
#voteCanvas{width:100%;height:120px;background:transparent;border-radius:6px;margin-top:8px}
.log{max-height:240px;overflow:auto;padding:6px;background:rgba(255,255,255,0.02);border-radius:8px;margin-top:8px}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <div>
      <div class="title">WINGO ULTRA LEVEL X ‚Äî BANGLA (v3.6)</div>
      <div class="subtitle">Cosmic Synaptic Ensemble ‚Ä¢ Right-Edge OCR ‚Ä¢ Number Prediction Mode</div>
    </div>
    <div class="small">‡¶°‡ßá‡¶ü‡¶æ ‡¶≤‡ßã‡¶ï‡¶æ‡¶≤‡¶ø ‡¶∏‡ßá‡¶≠ ‡¶π‡ßü ‚Ä¢ Deterministic</div>
  </div>

  <div class="grid">
    <!-- Left: Controls & Analysis -->
    <div class="card">
      <div style="font-weight:700">‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‚Äî (‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü/‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤)</div>
      <div class="small" style="margin-top:6px">‡ßß) ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü ‡¶Ü‡¶™‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡ßÅ‡¶® (‡¶™‡¶ø‡¶∞‡¶ø‡ßü‡¶°‡ßá‡¶∞ ‡¶°‡¶æ‡¶® ‡¶™‡¶æ‡¶∂‡ßá ‡¶¨‡ßú ‡¶∞‡¶ô‡¶ø‡¶® ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶•‡¶æ‡¶ï‡¶¨‡ßá)‡•§<br>‡ß®) ‡¶Ö‡¶•‡¶¨‡¶æ ‡¶®‡¶ø‡¶ö‡ßá ‡¶Æ‡ßç‡¶Ø‡¶æ‡¶®‡ßÅ‡ßü‡¶æ‡¶≤‡¶ø ‡¶∂‡ßá‡¶∑ 20 ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ (newest-first) ‡¶¨‡¶∏‡¶æ‡¶®, ‡¶∏‡ßç‡¶™‡ßá‡¶∏/‡¶ï‡¶Æ‡¶æ ‡¶¶‡¶ø‡ßü‡ßá ‡¶Ü‡¶≤‡¶æ‡¶¶‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§</div>

      <div style="margin-top:8px" class="row">
        <label style="display:inline-flex;align-items:center;gap:8px" class="uploader">
          <input id="screenshotFile" type="file" accept="image/*" />
          <button id="processScreenshotBtn" class="ghost">üñºÔ∏è ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü ‡¶™‡ßç‡¶∞‡¶ï‡ßç‡¶∞‡¶ø‡ßü‡¶æ ‡¶ï‡¶∞‡ßã</button>
        </label>
        <button id="pasteLastBtn" class="ghost">üìã ‡¶™‡ßÅ‡¶∞‡¶®‡ßã ‡¶á‡¶§‡¶ø‡¶π‡¶æ‡¶∏ ‡¶™‡ßá‡¶∏‡ßç‡¶ü ‡¶ï‡¶∞‡ßá ‡¶®‡¶æ‡¶ì</button>
      </div>

      <textarea id="inputBox" class="input" rows="4" placeholder="‡¶â‡¶¶‡¶æ‡¶π‡¶§‡¶É 7 2 5 5 1 8 3 6 0 2 4 5 5 2 3"></textarea>

      <div class="row" style="margin-top:8px">
        <button id="analyzeBtn" class="button">üîé ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶ï‡¶∞‡ßã</button>
        <button id="predictBtn" class="button">üéØ ‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶≠‡¶¨‡¶ø‡¶∑‡ßç‡¶Ø‡¶¶‡ßç‡¶¨‡¶æ‡¶£‡ßÄ</button>
        <button id="recordOpen" class="ghost">üìù ‡¶´‡¶≤ ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶ï‡¶∞‡ßã</button>
      </div>

      <div style="margin-top:10px;font-weight:700">OCR Preview / Parsed Numbers</div>
      <div id="ocrPreview" class="out small">‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶®‡ßá‡¶á</div>

      <div style="margin-top:10px;font-weight:700">Analysis</div>
      <div id="analysisOut" class="out">‡¶è‡¶ñ‡¶®‡ßã ‡¶è‡¶®‡¶æ‡¶≤‡¶æ‡¶á‡¶∏‡¶ø‡¶∏ ‡¶π‡ßü‡¶®‡¶ø‡•§</div>

      <div style="margin-top:8px;font-weight:700">Recent Log</div>
      <div id="log" class="log small"></div>
    </div>

    <!-- Right: Prediction, Memory, Stats -->
    <div class="card">
      <div style="font-weight:700">PRIMARY PREDICTION</div>
      <div id="predictionOut" class="out" style="font-size:16px">‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡ßá‡¶°‡¶ø‡¶ï‡¶∂‡¶® ‡¶®‡ßá‡¶á</div>

      <canvas id="voteCanvas"></canvas>

      <div style="margin-top:10px;font-weight:700">CAPITAL / MARTINGALE</div>
      <div id="capOut" class="out small">Level: 1 ‚Ä¢ Next Bet: ‚Çπ10 ‚Ä¢ Total Invested: ‚Çπ0</div>

      <div style="margin-top:10px;font-weight:700">PERFORMANCE</div>
      <div class="stat"><div>Total Rounds</div><div id="statTotal">0</div></div>
      <div class="stat"><div>Wins</div><div id="statWin">0</div></div>
      <div class="stat"><div>Losses</div><div id="statLoss">0</div></div>
      <div class="stat"><div>Accuracy</div><div id="statAcc">N/A</div></div>

      <div style="margin-top:10px;font-weight:700">AI_MEMORY_STATE</div>
      <pre id="aiState" class="mem"></pre>

      <div style="margin-top:8px" class="row">
        <button id="exportBtn" class="ghost">üì§ Export</button>
        <button id="importBtn" class="ghost">üì• Import</button>
        <button id="clearHistory" class="ghost">üßπ Reset All</button>
      </div>
    </div>
  </div>
</div>

<!-- Record Result Modal (simple) -->
<div id="recordCard" style="display:none;position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:50">
  <div style="background:var(--panel);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);min-width:320px">
    <div style="font-weight:700">Record Result (PID optional)</div>
    <input id="recPid" placeholder="PID (optional)" class="input" style="margin-top:8px"/>
    <input id="recNum" placeholder="Number 0-9" class="input" style="margin-top:8px"/>
    <div class="row" style="margin-top:8px;justify-content:flex-end">
      <button id="recSubmit" class="button">Confirm & Learn</button>
      <button id="recCancel" class="ghost">Cancel</button>
    </div>
  </div>
</div>

<script>
/* --------------------------
   AI_MEMORY_STATE (persist)
   --------------------------*/
const STORAGE_KEY = 'WULX_AI_MEMORY_v3_6';
function defaultState(){
  return {
    last_pid:null,
    history_newest_first:[], // {period?, number, ts}
    current_level:1,
    total_invested:0,
    last_top_logic:null,
    last_result:'N/A',
    last_prediction_pid:null,
    stats:{total:0,win:0,loss:0}
  };
}
let AI = (function(){ try{ const raw = localStorage.getItem(STORAGE_KEY); if(raw) return JSON.parse(raw);}catch(e){} const s=defaultState(); localStorage.setItem(STORAGE_KEY,JSON.stringify(s)); return s; })();
function saveAI(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(AI)); renderState(); }

/* --------------------------
   Utilities
   --------------------------*/
const $ = id => document.getElementById(id);
const now = ()=>Date.now();
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function asciiDigits(s){ if(!s) return ''; return s.replace(/[‡ß¶‡ßß‡ß®‡ß©‡ß™‡ß´‡ß¨‡ß≠‡ßÆ‡ßØ]/g,m=> '‡ß¶‡ßß‡ß®‡ß©‡ß™‡ß´‡ß¨‡ß≠‡ßÆ‡ßØ'.indexOf(m)); }

/* --------------------------
   Right-Edge Extractor (OCR)
   - Uses Tesseract to get text, then for each non-empty line:
     find tokens, prefer the right-most single digit token.
   - Provide preview and allow manual edit in inputBox.
   --------------------------*/
$('processScreenshotBtn').addEventListener('click', async ()=>{
  const files = $('screenshotFile').files;
  if(!files || files.length===0){ alert('‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡ßã'); return; }
  const file = files[0];
  $('ocrPreview').textContent = 'OCR: ‡¶ö‡¶≤‡¶õ‡ßá ‚Äî ‡¶¶‡ßü‡¶æ ‡¶ï‡¶∞‡ßá ‡¶Ö‡¶™‡ßá‡¶ï‡ßç‡¶∑‡¶æ ‡¶ï‡¶∞‡ßã...';
  try{
    const { createWorker } = Tesseract;
    const worker = createWorker({ logger: m=>{} });
    await worker.load();
    await worker.loadLanguage('eng');
    await worker.initialize('eng');
    await worker.setParameters({ tessedit_char_whitelist: '0123456789‡ß¶‡ßß‡ß®‡ß©‡ß™‡ß´‡ß¨‡ß≠‡ßÆ‡ßØ: ', preserve_interword_spaces: '1' });
    const { data:{ text } } = await worker.recognize(file);
    await worker.terminate();
    // split lines, for each take last single-digit token if present
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    const parsed = [];
    for(const line of lines){
      // normalize bengali digits to ascii
      const normalized = line.replace(/[‡ß¶‡ßß‡ß®‡ß©‡ß™‡ß´‡ß¨‡ß≠‡ßÆ‡ßØ]/g, ch => '‡ß¶‡ßß‡ß®‡ß©‡ß™‡ß´‡ß¨‡ß≠‡ßÆ‡ßØ'.indexOf(ch));
      // find all digit tokens
      const tokens = normalized.match(/\d+/g);
      if(!tokens) continue;
      // pick the right-most token that is a single digit, else take last digit of last token
      let chosen = null;
      for(let i = tokens.length-1;i>=0;i--){
        if(tokens[i].length === 1){ chosen = tokens[i]; break; }
      }
      if(!chosen){
        // fallback: use last digit of last token
        const lastTok = tokens[tokens.length-1];
        chosen = lastTok.charAt(lastTok.length-1);
      }
      if(chosen !== null) parsed.push(chosen);
    }
    if(parsed.length < 6){
      $('ocrPreview').textContent = 'INPUT ERROR: OCR‚Äì‡¶è ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ' + parsed.length + ' ‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶ó‡ßá‡¶õ‡ßá ‚Äî ‡¶™‡¶∞‡¶ø‡¶∑‡ßç‡¶ï‡¶æ‡¶∞ ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶®‡¶∂‡¶ü ‡¶¶‡¶æ‡¶ì‡•§';
      return;
    }
    // newest-first assumption: OCR usually reads top‚Üídown = newest-first may vary; we will place as parsed order.
    $('ocrPreview').textContent = 'OCR parsed (right-edge): ' + parsed.join(', ');
    // place into inputBox for user to confirm/edit
    $('inputBox').value = parsed.join(' ');
    logAdd('OCR parsed ' + parsed.length + ' numbers');
  } catch(err){
    console.error(err);
    $('ocrPreview').textContent = 'OCR failed ‚Äî console ‡¶¶‡ßá‡¶ñ‡ßã';
  }
});

/* --------------------------
   Ensemble Methods (deterministic heuristics)
   Return suggestions per digit/class
   --------------------------*/
function computeDigitScores(historyNums){
  // historyNums: newest-first array of ints
  const W = Math.min(historyNums.length, 200);
  const window = historyNums.slice(0, W);
  const freq = Array(10).fill(0);
  const recency = Array(10).fill(0);
  const lastSeen = Array(10).fill(9999);
  for(let i=0;i<window.length;i++){
    const v = window[i];
    freq[v]++;
    recency[v] += (W - i);
    if(lastSeen[v]===9999) lastSeen[v] = i;
  }
  // compute run length for last class
  let runDigit = window.length? window[0] : null;
  let runLen = 0;
  for(let i=0;i<window.length;i++){ if(window[i]===runDigit) runLen++; else break; }

  // features to combine deterministically:
  // - freq normalized
  // - recency normalized
  // - inverse lastSeen (gap)
  // - runBoost for the repeated digit
  const maxFreq = Math.max(...freq,1);
  const maxRecency = window.length*(window.length+1)/2 || 1;
  const scores = [];
  for(let d=0; d<10; d++){
    const f = freq[d]/maxFreq;
    const r = recency[d]/maxRecency;
    const gap = 1 - clamp(lastSeen[d]/30, 0, 1);
    const runBoost = (d===runDigit)? clamp(runLen/6, 0, 1) : 0;
    // fibonacci proximity: if d in fibonacci sequence generated from recent two
    let fibBoost = 0;
    if(window.length>=2){
      let a = window[1], b = window[0];
      for(let k=0;k<6;k++){ const z = (a+b)%10; if(z===d) fibBoost = 0.06; a=b; b=z; }
    }
    // small penalty for 0 and 5 (violet damp)
    const violet = (d===0 || d===5)? 0.9 : 1.0;
    // base score linear combination (deterministic weights)
    const score = (f*0.46 + r*0.28 + gap*0.12 + runBoost*0.08 + fibBoost*0.06) * violet;
    scores.push({d,score,freq:freq[d],lastSeen:lastSeen[d]});
  }
  // normalize scores to sum 1
  const sum = scores.reduce((s,x)=>s+x.score,0) || 1;
  scores.forEach(s=>s.prob = s.score/sum);
  // sort by score desc, tie by freq then lastSeen then smaller digit
  scores.sort((a,b)=> b.score - a.score || b.freq - a.freq || a.lastSeen - b.lastSeen || a.d - b.d);
  return scores;
}

/* Aggregate to Top2 digits & class prediction */
function aggregatePrediction(historyNums){
  const digitScores = computeDigitScores(historyNums); // sorted desc
  const top2 = digitScores.slice(0,2).map(x=>x.d);
  // class (BIG/SMALL) by sum of probs of digits >=5
  const bigProb = digitScores.reduce((s,x)=> s + (x.d>=5? x.prob : 0), 0);
  const smallProb = 1 - bigProb;
  const predictedClass = bigProb >= smallProb ? 'BIG' : 'SMALL';
  // confidence derived from dominance ratio and spread
  const dom = digitScores[0].prob;
  const spread = dom - digitScores[1].prob;
  // deterministic mapping to percent
  let confidence = Math.round( clamp( (0.30 + dom*0.6 + spread*0.4) * 100, 30, 99 ) );
  // if many signals align (runLen large & top digit frequent) boost
  const runLenApprox = (()=>{ let r=0; for(let i=1;i<historyNums.length;i++){ if(historyNums[i-1]===historyNums[i]) r++; else break;} return r; })();
  if(runLenApprox>=4 && digitScores[0].freq>=3) confidence = Math.max(confidence, 92);
  return { top2, topDigit: digitScores[0].d, bigProb: Math.round(bigProb*100), smallProb: Math.round(smallProb*100), predictedClass, confidence, digitScores };
}

/* --------------------------
   UI Handlers
   --------------------------*/
function renderPredictionBlock(agg){
  $('predictionOut').innerHTML = `
    <div style="font-weight:700">SIZE: ${agg.predictedClass}  ‚Ä¢  CONFIDENCE: ${agg.confidence}%</div>
    <div style="margin-top:6px">TOP 2 DIGITS: <strong>${agg.top2.join(' , ')}</strong></div>
    <div style="margin-top:6px">TOP DIGIT SUGGESTION: <span style="font-size:20px;font-weight:800">${agg.topDigit}</span></div>
    <div style="margin-top:6px" class="small">Prob (BIG): ${agg.bigProb}% ‚Ä¢ Prob (SMALL): ${agg.smallProb}%</div>
  `;
  drawVotes(agg.digitScores);
  AI.last_top_logic = 'cosmic_ensemble_v3';
  AI.last_prediction_pid = {pid: AI.last_pid || 'NEXT', top2: agg.top2, topDigit: agg.topDigit, predictedClass: agg.predictedClass, confidence: agg.confidence};
  saveAI();
}

function drawVotes(digitScores){
  const canvas = $('voteCanvas'); const ctx = canvas.getContext('2d');
  canvas.width = canvas.clientWidth; canvas.height = 120; ctx.clearRect(0,0,canvas.width,canvas.height);
  const w = canvas.width; const h = canvas.height; const barW = (w-20)/10;
  const maxScore = Math.max(...digitScores.map(x=>x.score), 0.0001);
  for(let i=0;i<10;i++){
    const ds = digitScores.find(x=>x.d===i) || {score:0};
    const barH = (ds.score/maxScore) * (h-40);
    const x = 10 + i*barW;
    ctx.fillStyle = (i>=5? '#34d399' : '#fb7185');
    ctx.fillRect(x, h-20-barH, barW*0.7, barH);
    ctx.fillStyle = '#cfefff';
    ctx.font = '12px monospace';
    ctx.fillText(i.toString(), x+6, h-4);
  }
}

/* --------------------------
   Analyze & Predict buttons
   --------------------------*/
$('analyzeBtn').addEventListener('click', ()=>{
  const txt = $('inputBox').value.trim();
  const parsed = parseInputText(txt);
  if(parsed.numbers.length < 6){ $('analysisOut').textContent = 'INPUT ERROR: ‡¶ï‡¶Æ‡¶™‡¶ï‡ßç‡¶∑‡ßá 6‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶¶‡¶∞‡¶ï‡¶æ‡¶∞‡•§'; return; }
  $('analysisOut').textContent = `Analyzed ${parsed.numbers.length} numbers (newest-first).`;
  const agg = aggregatePrediction(parsed.numbers);
  renderPredictionBlock(agg);
  logAdd(`Analyzed ${parsed.numbers.length} numbers ‚Üí Class:${agg.predictedClass} Top:${agg.topDigit} (${agg.confidence}%)`);
});

$('predictBtn').addEventListener('click', ()=>{
  const txt = $('inputBox').value.trim();
  let arr = parseInputText(txt).numbers;
  if(!arr.length && AI.history_newest_first.length) arr = AI.history_newest_first.map(h=>h.number);
  if(arr.length < 6){ alert('‡¶á‡¶§‡¶ø‡¶π‡¶æ‡¶∏ 6+ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶®‡¶æ‡¶ì, ‡¶Ö‡¶®‡ßÅ‡¶ó‡ßç‡¶∞‡¶π ‡¶ï‡¶∞‡ßá ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶¨‡¶æ ‡¶á‡¶§‡¶ø‡¶π‡¶æ‡¶∏ ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡ßã'); return; }
  const agg = aggregatePrediction(arr);
  renderPredictionBlock(agg);
  logAdd(`Predict NEXT ‚Üí Class:${agg.predictedClass} Top:${agg.topDigit} (${agg.confidence}%)`);
});

/* --------------------------
   Parsing helper for manual input
   Accepts "period:number" lines or plain digits
   Returns newest-first numbers array and lastPeriod
   --------------------------*/
function parseInputText(text){
  if(!text) return {numbers:[], lastPeriod:null};
  text = text.replace(/\r/g, '\n');
  const lines = text.split('\n').map(s=>s.trim()).filter(Boolean);
  const numbers=[];
  let lastPeriod = null;
  for(const line of lines){
    if(/[:\-]/.test(line) && /\d/.test(line)){
      const parts = line.split(/[:\-]/).map(s=>s.trim()).filter(Boolean);
      const lastTok = parts[parts.length-1];
      const md = lastTok.match(/\d$/);
      if(md) numbers.push(parseInt(md[0],10));
      const left = parts[0];
      if(left && left.length>4 && /^\d+$/.test(left)) lastPeriod = left;
    } else {
      const toks = line.split(/[\s,;]+/).filter(Boolean);
      for(const t of toks){
        const m = t.match(/[0-9]/);
        if(m) numbers.push(parseInt(m[0],10));
      }
    }
  }
  // newest-first: assume input provided newest-first; if user provided oldest-first they can reverse manually
  return {numbers, lastPeriod};
}

/* --------------------------
   Record result (learning) & martingale update
   --------------------------*/
$('recordOpen').addEventListener('click', ()=>{ $('recordCard').style.display='block'; });
$('recCancel').addEventListener('click', ()=>{ $('recordCard').style.display='none'; });

$('recSubmit').addEventListener('click', ()=>{
  const pid = $('recPid').value.trim() || null;
  const nRaw = $('recNum').value.trim();
  const n = parseInt(nRaw,10);
  if(isNaN(n) || n<0 || n>9){ alert('0-9 ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶¶‡¶ø‡¶®'); return; }
  // record
  AI.history_newest_first.unshift({period: pid, number: n, ts: now()});
  if(AI.history_newest_first.length > 1440) AI.history_newest_first.length = 1440;
  // update stats & martingale
  AI.stats.total = (AI.stats.total||0) + 1;
  const lastPred = AI.last_prediction_pid;
  let resultWin = false;
  if(lastPred && lastPred.top2 && lastPred.top2.includes(n)){ resultWin = true; }
  const actualClass = n>=5? 'BIG':'SMALL';
  if(lastPred && lastPred.predictedClass === actualClass) resultWin = true;
  if(resultWin){
    AI.stats.win = (AI.stats.win||0) + 1;
    AI.last_result = 'WIN';
    AI.current_level = 1;
  } else {
    AI.stats.loss = (AI.stats.loss||0) + 1;
    AI.last_result = 'LOSS';
    AI.current_level = (AI.current_level||1) + 1;
  }
  // stake accounting (3x martingale)
  const stake = 10 * Math.pow(3, (AI.current_level||1)-1);
  AI.total_invested = (AI.total_invested||0) + stake;
  AI.last_pid = pid || AI.last_pid;
  saveAI();
  renderState();
  $('recordCard').style.display='none';
  logAdd(`Recorded PID:${pid||'-'} Number:${n} ‚Üí ${AI.last_result}`);
});

/* --------------------------
   State rendering & helpers
   --------------------------*/
function renderState(){
  $('aiState').textContent = JSON.stringify(AI, null, 2);
  $('statTotal').textContent = AI.stats.total || 0;
  $('statWin').textContent = AI.stats.win || 0;
  $('statLoss').textContent = AI.stats.loss || 0;
  const acc = AI.stats.total ? Math.round((AI.stats.win/AI.stats.total)*1000)/10 : 'N/A';
  $('statAcc').textContent = acc === 'N/A' ? 'N/A' : acc + '%';
  $('capOut').textContent = `Level: ${AI.current_level||1} ‚Ä¢ Next Bet: ‚Çπ${10 * Math.pow(3, (AI.current_level||1)-1)} ‚Ä¢ Total Invested: ‚Çπ${AI.total_invested||0}`;
}
function logAdd(txt){
  const div = $('log');
  const nowStr = new Date().toLocaleString('bn-BD');
  const el = document.createElement('div'); el.textContent = `${nowStr} ‚Äî ${txt}`; div.insertBefore(el, div.firstChild);
  // keep log length reasonable
  while(div.childNodes.length > 200) div.removeChild(div.lastChild);
}

/* export/import/reset */
$('exportBtn').addEventListener('click', ()=>{
  const blob = new Blob([JSON.stringify(AI, null, 2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'wulx_ai_memory.json'; a.click();
});
$('importBtn').addEventListener('click', ()=>{
  const fi = document.createElement('input'); fi.type='file'; fi.accept='.json'; fi.onchange = e=>{
    const f = e.target.files[0]; if(!f) return;
    const r = new FileReader(); r.onload = ev => {
      try{ const obj = JSON.parse(ev.target.result); if(obj && obj.history_newest_first){ AI = obj; saveAI(); alert('Imported.'); } else alert('Invalid file'); } catch(err){ alert('Import failed'); }
    }; r.readAsText(f);
  }; fi.click();
});
$('clearHistory').addEventListener('click', ()=>{
  if(!confirm('‡¶∏‡¶¨ history ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶§‡ßá ‡¶ö‡¶æ‡¶ì?')) return;
  AI = defaultState(); saveAI(); renderState(); logAdd('State reset');
});

/* Paste last history helper (from local state) */
$('pasteLastBtn').addEventListener('click', ()=> {
  if(!AI.history_newest_first.length) return alert('‡¶ï‡ßã‡¶®‡ßã history ‡¶®‡ßá‡¶á');
  const nums = AI.history_newest_first.slice(0,20).map(h=>h.number).join(' ');
  $('inputBox').value = nums;
  $('ocrPreview').textContent = '‡¶™‡ßÇ‡¶∞‡ßç‡¶¨‡ßá‡¶∞ local history pasted.';
});

/* init */
renderState();
if(AI.history_newest_first.length){
  logAdd('Loaded local history (' + AI.history_newest_first.length + ' records)');
}

/* ensure canvas initial */
drawVotes(Array.from({length:10},(_,i)=>({d:i,score:0.001})));

</script>
</body>
</html>
