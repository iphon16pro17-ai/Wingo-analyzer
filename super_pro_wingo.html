<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wingo Super Pro Analyzer (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ)</title>
<style>
  :root{--bg:#071026;--card:#0f1724;--muted:#94a3b8;--accent:#06b6d4;--good:#10b981;--bad:#fb7185;}
  body{font-family: "Noto Sans", "Noto Sans Bengali", system-ui, Arial; background:var(--bg); color:#e6eef8; margin:0; padding:16px;}
  .wrap{max-width:820px;margin:0 auto;}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  h1{font-size:20px;margin:0;color:#7dd3fc}
  .card{background:var(--card);border-radius:12px;padding:14px;margin-bottom:12px;box-shadow:0 6px 24px rgba(2,6,23,.6)}
  label{color:var(--muted);font-size:13px}
  textarea{width:100%;min-height:110px;background:#061426;border:1px solid #1f2937;color:#e6eef8;padding:10px;border-radius:8px;font-size:15px;resize:vertical}
  input,select,button{font-size:15px}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .btn{background:var(--accent);color:#022; padding:9px 14px;border-radius:8px;border:none;cursor:pointer;font-weight:700}
  .btn.alt{background:#334155;color:#e6eef8}
  .out{background:#041226;padding:12px;border-radius:10px;margin-top:10px;color:#dbeafe}
  .badge{display:inline-block;padding:6px 8px;border-radius:8px;background:#071b2b;color:#c7f9ff;margin-right:6px;font-weight:700}
  .meter{height:12px;background:#0b1220;border-radius:999px;overflow:hidden;margin-top:6px}
  .meter > i{display:block;height:100%;background:linear-gradient(90deg,var(--good),var(--accent));width:0%}
  pre{white-space:pre-wrap;word-break:break-word}
  .small{color:var(--muted);font-size:13px}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  @media(max-width:700px){ .grid{grid-template-columns:1fr} }
  .tbl{background:#071e2a;padding:8px;border-radius:8px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <div>
        <h1>üéØ Wingo Super Pro Analyzer (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ)</h1>
        <div class="small">0‚Äì4 = SMALL | 5‚Äì9 = BIG ‚Äî Pro level ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ (‡¶∂‡ßá‡¶∑ 10‚Äì100 ‡¶∞‡ßá‡¶ï‡¶∞‡ßç‡¶° ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶ï‡¶∞‡¶¨‡ßá)</div>
      </div>
    </header>

    <label>Numbers (‡¶ï‡¶Æ‡¶æ/‡¶∏‡ßç‡¶™‡ßá‡¶∏/‡¶°‡¶ü ‡¶Ø‡ßá‡¶≠‡¶æ‡¶¨‡ßá‡¶á ‡¶Ü‡¶õ‡ßá ‡¶¨‡¶∏‡¶æ‡¶ì) ‚Äî ‡¶∏‡¶∞‡ßç‡¶¨‡¶∂‡ßá‡¶∑ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ **‡¶è‡¶ï ‡¶≤‡¶æ‡¶á‡¶®‡ßá** ‡¶¶‡¶ø‡¶® (10‚Äì100):</label>
    <textarea id="nums" placeholder="‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: 5 8 3 6 0 0 5 2 5 5 6 0 3 7 0 8 2 5 8 1"></textarea>

    <div style="margin-top:8px" class="row">
      <button class="btn" id="analyze">üîé ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶ï‡¶∞‡ßã (Pro)</button>
      <button class="btn alt" id="clear">üßπ ‡¶ï‡ßç‡¶≤‡¶ø‡ßü‡¶æ‡¶∞</button>
      <button class="btn alt" id="voiceToggle">üîä ‡¶ï‡¶£‡ßç‡¶† ‡¶Ü‡¶â‡¶ü‡¶™‡ßÅ‡¶ü: Off</button>
    </div>
    <div class="small" style="margin-top:8px">‡¶®‡ßã‡¶ü: ‡¶Ø‡¶§ ‡¶¨‡ßá‡¶∂‡¶ø ‡¶á‡¶§‡¶ø‡¶π‡¶æ‡¶∏ (‡ß®‡ß¶‚Äì‡ß´‡ß¶) ‡¶¶‡ßá‡¶¨‡ßá, ‡¶§‡¶§ ‡¶¨‡ßá‡¶∂‡¶ø ‡¶®‡¶ø‡¶∞‡ßç‡¶≠‡¶∞‡¶Ø‡ßã‡¶ó‡ßç‡¶Ø ‡¶π‡¶¨‡ßá‡•§</div>
  </div>

  <div id="resultCard" class="card" style="display:none"></div>
</div>

<script>
(function(){
  const el = id=>document.getElementById(id);
  const btn = el('analyze'), clr = el('clear'), voiceBtn = el('voiceToggle');
  let speakOn = false;
  voiceBtn.addEventListener('click', ()=>{ speakOn = !speakOn; voiceBtn.textContent = speakOn? 'üîä ‡¶ï‡¶£‡ßç‡¶† ‡¶Ü‡¶â‡¶ü‡¶™‡ßÅ‡¶ü: On' : 'üîä ‡¶ï‡¶£‡ßç‡¶† ‡¶Ü‡¶â‡¶ü‡¶™‡ßÅ‡¶ü: Off'; });

  function parseInput(text){
    if(!text) return [];
    // normalize: replace dots, semicolons with commas, then split by non-digit
    const cleaned = text.replace(/[Ÿ´‡•§¬∑‚Ä¢ŸÄ]/g,',').replace(/[^\d,]+/g,',');
    const parts = cleaned.split(',').map(s=>s.trim()).filter(s=>s!=='');
    const nums = parts.map(p=>{
      // allow multi-digit but only keep last digit (defensive)
      const m = p.match(/\d+$/);
      return m? parseInt(m[0].slice(-1),10) : null;
    }).filter(n=>n!==null && n>=0 && n<=9);
    return nums;
  }

  function classify(n){ return n>=5 ? 'BIG' : 'SMALL'; }

  function longestRun(types){
    if(types.length===0) return {type:null,len:0};
    let curr = types[0], curLen=1, bestType=curr, bestLen=1;
    for(let i=1;i<types.length;i++){
      if(types[i]===curr) curLen++; else { if(curLen>bestLen){bestLen=curLen;bestType=curr;} curr=types[i]; curLen=1; }
    }
    if(curLen>bestLen){bestLen=curLen;bestType=curr;}
    return {type:bestType,len:bestLen};
  }

  // pattern echo: return fraction 0..1 indicating how much last k-seq existed earlier
  function patternEcho(arr){
    if(arr.length < 6) return 0;
    const s = arr.join(',');
    const maxLen = Math.min(8, Math.floor(arr.length/2));
    let score = 0;
    for(let len=2; len<=maxLen; len++){
      const tail = arr.slice(-len).join(',');
      const idx = s.lastIndexOf(tail);
      if(idx !== -1 && idx < s.length - tail.length - 1){
        score += len / maxLen;
      }
    }
    return Math.min(1, score / 3);
  }

  // compute gap statistics for each digit (average gap between occurrences)
  function gapStats(arr){
    const lastIndex = {};
    const gaps = {}; for(let d=0; d<=9; d++){gaps[d]=[];}
    for(let i=0;i<arr.length;i++){
      const v = arr[i];
      if(lastIndex[v] !== undefined){
        gaps[v].push(i - lastIndex[v]);
      }
      lastIndex[v] = i;
    }
    const avgGap = {};
    for(let d=0; d<=9; d++){
      const g = gaps[d];
      avgGap[d] = g.length? (g.reduce((a,b)=>a+b,0)/g.length) : null;
    }
    return avgGap;
  }

  function analyzeSeries(nums){
    const total = nums.length;
    const types = nums.map(n=> classify(n));
    const bigCount = types.filter(t=>t==='BIG').length;
    const smallCount = total - bigCount;

    // windows
    const last3 = nums.slice(-3), last5 = nums.slice(-5), last10 = nums.slice(-10);
    const last3TypeBias = (last3.filter(n=>n>=5).length - (3 - last3.filter(n=>n>=5).length)) / 3; // -1..1
    const last5Bias = (last5.filter(n=>n>=5).length/last5.length);
    const last10Bias = (last10.filter(n=>n>=5).length/last10.length);

    const streak = (()=>{ // last contiguous same-size streak count
      if(types.length===0) return {type:null,len:0};
      let t = types[types.length-1], len=1;
      for(let i=types.length-2;i>=0;i--){
        if(types[i]===t) len++; else break;
      }
      return {type:t,len:len};
    })();

    const longest = longestRun(types);
    const echo = patternEcho(nums);
    const gaps = gapStats(nums);

    // Weighted scoring components (deterministic weights)
    // Each component returns score favoring BIG in 0..1 (0 => strong SMALL, 1 => strong BIG)
    const comp = {};

    // 1) Recent bias (last5) -> linear map [0..1]
    comp.recent = last5Bias; // 0..1

    // 2) Momentum (last3): map -1..1 -> 0..1
    comp.momentum = (last3TypeBias + 1) / 2;

    // 3) Streak reversal: if last streak is long for SMALL => favor BIG
    comp.streakRev = 0.5;
    if(streak.type === 'SMALL'){
      if(streak.len >= 7) comp.streakRev = 0.99;
      else if(streak.len >= 5) comp.streakRev = 0.92;
      else if(streak.len === 4) comp.streakRev = 0.80;
      else if(streak.len === 3) comp.streakRev = 0.58;
      else comp.streakRev = 0.45;
    } else if(streak.type === 'BIG'){
      // long big streak increases chance of small; so favor BIG low
      if(streak.len >= 7) comp.streakRev = 0.08;
      else if(streak.len >=5) comp.streakRev = 0.18;
      else if(streak.len === 4) comp.streakRev = 0.30;
      else if(streak.len === 3) comp.streakRev = 0.50;
      else comp.streakRev = 0.6;
    } else comp.streakRev = 0.5;

    // 4) Pattern echo: if recent pattern has been seen earlier, it favors continuation of that pattern.
    // We'll compute a direction from recent majority
    const recentMajority = (last5.filter(n=>n>=5).length >= 3) ? 1 : 0;
    comp.echo = echo * (recentMajority===1 ? 1.0 : 0.0); // only boost BIG if recent majority Big else 0

    // 5) Balance correction: overall bigRatio
    const overallBigRatio = bigCount / total;
    // Convert to favor BIG: if overallBigRatio low then favor BIG more for correction
    comp.balance = 1 - overallBigRatio; // if many small overall, comp.balance >0.5

    // 6) gap based: if certain digits are overdue (large avg gap) and they are BIG digits, increase BIG preference slightly
    let gapBoost = 0;
    const avgGaps = gaps;
    // compute top candidates overdue among big digits
    const bigDigits = [5,6,7,8,9];
    let overdueCount = 0, considered = 0;
    for(const d of bigDigits){
      if(avgGaps[d] === null) continue;
      considered++;
      if(avgGaps[d] >= 6) overdueCount++;
    }
    if(considered>0) gapBoost = Math.min(0.08, (overdueCount/considered)*0.08);
    comp.gap = 0.5 + gapBoost; // near 0.5 base

    // aggregate with weights
    // weights chosen deterministically
    const weights = {recent:0.26,momentum:0.18,streakRev:0.28,echo:0.12,balance:0.10,gap:0.06};
    const bigScore = (comp.recent*weights.recent + comp.momentum*weights.momentum + comp.streakRev*weights.streakRev + comp.echo*weights.echo + comp.balance*weights.balance + comp.gap*weights.gap);
    // normalize by sum of weights (which is 1.0)
    const bigPct = Math.round(bigScore*100);
    const smallPct = 100 - bigPct;

    // Confidence calculation: based on component strengths + streak length + echo
    const compMax = Math.max(Math.abs((comp.recent-0.5)*2), Math.abs((comp.momentum-0.5)*2), Math.abs((comp.streakRev-0.5)*2), comp.echo, Math.abs((comp.balance-0.5)*2));
    const confidence = Math.min(98, Math.round(45 + compMax*50 + (streak.len>2? Math.min(10, streak.len*2) : 0) + echo*5));

    // Top digit candidates by simple heuristic: frequency + recency boost
    const freq = {};
    for(let d=0; d<=9; d++) freq[d]=0;
    for(let i=0;i<nums.length;i++) freq[nums[i]]++;
    // candidate score = freq normalized + recency multiplier if in last 5
    const last5Set = new Set(last5);
    const cand = [];
    for(let d=0; d<=9; d++){
      let score = (freq[d]/Math.max(1,total)) * 0.6 + (last5Set.has(d)?0.4:0);
      cand.push({d,score});
    }
    cand.sort((a,b)=>b.score-a.score);
    const top3 = cand.slice(0,3).map(c=>c.d);

    return {
      total, bigCount, smallCount, last3, last5, last10,
      last5Bias, last10Bias, streak, longest, echo, avgGaps, bigPct, smallPct, confidence, top3, components: comp
    };
  }

  function prettyReport(nums, res){
    // build HTML
    const lastSeq = nums.slice(-Math.min(nums.length,50)).join(', ');
    const html = [];
    html.push('<div style="font-weight:700;font-size:16px;margin-bottom:6px">üîé ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶¨‡ßá‡¶¶‡¶® (Pro)</div>');
    html.push(`<div class="small">‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶ø‡¶§ ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ (‡¶∂‡ßá‡¶∑ ${res.total}): <b>${lastSeq}</b></div>`);
    html.push('<div style="margin-top:8px" class="tbl">');
    html.push(`<div>üìä ‡¶∏‡¶æ‡¶Æ‡ßç‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ï ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ (last10): <b>${res.last10.join(', ')}</b></div>`);
    html.push(`<div style="margin-top:6px">BIG: <b>${res.bigCount}</b>  |  SMALL: <b>${res.smallCount}</b></div>`);
    html.push(`<div style="margin-top:6px">üîÅ ‡¶ü‡¶æ‡¶®‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶ï: <b>${res.streak.type}</b> √ó <b>${res.streak.len}</b></div>`);
    html.push(`<div style="margin-top:6px">üìà ‡¶¨‡ßú‡ßá‡¶∞ ‡¶∏‡¶Æ‡ßç‡¶≠‡¶æ‡¶¨‡ßç‡¶Ø‡¶§‡¶æ: <b style="color:${res.bigPct>res.smallPct? '#34d399':'#fb7185'}">${res.bigPct}%</b>  ‚Äî ‡¶õ‡ßã‡¶ü: ${res.smallPct}%</div>`);
    html.push(`<div style="margin-top:6px">üîê ‡¶Ü‡¶§‡ßç‡¶Æ‡¶¨‡¶ø‡¶∂‡ßç‡¶¨‡¶æ‡¶∏: <b>${res.confidence}%</b></div>`);
    html.push(`<div style="margin-top:8px">üßæ ‡¶ü‡ßç‡¶∞‡ßá‡¶®‡ßç‡¶° ‡¶ü‡¶æ‡¶á‡¶™: <b>${(res.components.streakRev>0.6? 'Reversal-biased' : (res.last5Bias>0.6? 'Momentum Big' : 'Mixed'))}</b></div>`);
    html.push(`<div style="margin-top:8px">üéØ ‡¶∏‡¶Æ‡ßç‡¶≠‡¶æ‡¶¨‡ßç‡¶Ø ‡¶∂‡ßÄ‡¶∞‡ßç‡¶∑ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞ (Top 3): <b>${res.top3.join(', ')}</b> (Historical freq + recency)</div>`);
    html.push(`<div style="margin-top:8px">üî¨ ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶á‡¶ï‡ßã ‡¶∏‡ßç‡¶ï‡ßã‡¶∞: <b>${(res.echo*100).toFixed(0)}%</b> (0 ‚Üí ‡¶®‡¶§‡ßÅ‡¶® ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶®, 100 ‚Üí ‡¶Ü‡¶ó‡ßá ‡¶¶‡ßá‡¶ñ‡¶æ ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶®)</div>`);
    html.push('</div>');

    html.push('<div style="margin-top:10px">');
    html.push('<b>‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶ï‡¶æ‡¶∞‡¶£:</b>');
    html.push('<ul>');
    // reasons
    if(res.streak.len >= 4){
      html.push(`<li>‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶ï ‡¶°‡¶ø‡¶ü‡ßá‡¶ï‡¶∂‡¶®: ‡¶∂‡ßá‡¶∑ ${res.streak.len} ‡¶ü‡¶ø ‡¶ß‡¶æ‡¶∞‡¶æ‡¶¨‡¶æ‡¶π‡¶ø‡¶ï "${res.streak.type}" ‚Äî ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶ï-‡¶∞‡¶ø‡¶≠‡¶æ‡¶∞‡ßç‡¶∏ ‡¶∏‡¶Æ‡ßç‡¶≠‡¶æ‡¶¨‡ßç‡¶Ø‡¶§‡¶æ ‡¶¨‡ßÉ‡¶¶‡ßç‡¶ß‡¶ø ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡•§</li>`);
    } else {
      html.push(`<li>‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶ï ‡¶≤‡ßá‡¶® ‡¶ï‡¶Æ: ${res.streak.len} ‚Äî ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶ø‡¶ï ‡¶è‡¶≤‡¶æ‡¶∞‡ßç‡¶Æ ‡¶®‡ßá‡¶á‡•§</li>`);
    }
    html.push(`<li>Recent bias (last 5) Big-ratio: ${(res.last5Bias*100).toFixed(0)}%</li>`);
    html.push(`<li>Momentum (last3): ${(res.components.momentum*100).toFixed(0)}% ‚Üí positive favors BIG</li>`);
    html.push(`<li>Balance-correction factor: ${(res.components.balance*100).toFixed(0)}% (‡¶Ø‡¶§ ‡¶ï‡¶Æ overall Big, ‡¶§‡¶§ ‡¶¨‡ßá‡¶∂‡ßÄ correction favor Big)</li>`);
    html.push(`<li>Gap-based boost for overdue big digits: ${( (res.components.gap-0.5)*100 ).toFixed(1)}%</li>`);
    html.push('</ul>');
    html.push('</div>');

    html.push('<div style="margin-top:10px" class="small">‚ö†Ô∏è ‡¶∏‡ßç‡¶Æ‡¶∞‡¶£‡ßÄ‡ßü: ‡¶è‡¶ü‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶™‡¶∞‡¶ø‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶®‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø‡¶ï ‡¶Ü‡¶®‡ßÅ‡¶Æ‡¶æ‡¶®‡¶ø‡¶ï ‡¶¨‡¶ø‡¶∂‡ßç‡¶≤‡ßá‡¶∑‡¶£ ‚Äî ‡¶¨‡¶æ‡¶∏‡ßç‡¶§‡¶¨ ‡¶´‡¶≤ ‡¶™‡ßÅ‡¶∞‡ßã‡¶ü‡¶æ‡¶á ‡¶∞‚Äç‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶Æ ‡¶π‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡•§ ‡¶¨‡¶æ‡¶ú‡¶ø ‡¶¨‡¶æ ‡¶∏‡¶ø‡¶¶‡ßç‡¶ß‡¶æ‡¶®‡ßç‡¶§ ‡¶®‡ßá‡ßü‡¶æ‡¶∞ ‡¶Ü‡¶ó‡ßá ‡¶®‡¶ø‡¶ú‡ßá‡¶á ‡¶¨‡¶ø‡¶¨‡ßá‡¶ö‡¶®‡¶æ ‡¶ï‡¶∞‡ßã‡•§</div>');
    return html.join('');
  }

  btn.addEventListener('click', ()=>{
    const raw = el('nums').value || '';
    const nums = parseInput(raw);
    const out = el('resultCard');
    if(nums.length < 6){ out.style.display='block'; out.innerHTML = `<div class="out"><b>‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø:</b> ‡¶ï‡¶Æ‡¶™‡¶ï‡ßç‡¶∑‡ßá ‡ß¨‡¶ü‡¶ø ‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶™‡ßç‡¶∞‡ßü‡ßã‡¶ú‡¶® (‡¶è‡¶ñ‡¶® ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶ó‡ßá‡¶õ‡ßá ${nums.length})</div>`; return; }
    if(nums.length > 200) { out.style.display='block'; out.innerHTML = `<div class="out"><b>‡¶§‡ßç‡¶∞‡ßÅ‡¶ü‡¶ø:</b> ‡¶∏‡¶∞‡ßç‡¶¨‡ßã‡¶ö‡ßç‡¶ö ‡ß®‡ß¶‡ß¶ ‡¶á‡¶®‡¶™‡ßÅ‡¶ü ‡¶∏‡¶Æ‡¶∞‡ßç‡¶•‡¶® ‡¶ï‡¶∞‡ßá‡•§</div>`; return; }

    const res = analyzeSeries(nums);
    out.style.display='block';
    out.innerHTML = prettyReport(nums, res);

    if(speakOn && 'speechSynthesis' in window){
      const txt = `‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶∏‡¶Æ‡ßç‡¶≠‡¶æ‡¶¨‡ßç‡¶Ø ‡¶´‡¶≤: ${res.bigPct > res.smallPct ? '‡¶¨‡ßú' : '‡¶õ‡ßã‡¶ü'}, ‡¶Ü‡¶§‡ßç‡¶Æ‡¶¨‡¶ø‡¶∂‡ßç‡¶¨‡¶æ‡¶∏ ${res.confidence} ‡¶∂‡¶§‡¶æ‡¶Ç‡¶∂‡•§`;
      const msg = new SpeechSynthesisUtterance(txt);
      msg.lang = 'bn-BD';
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(msg);
    }
  });

  clr.addEventListener('click', ()=>{ el('nums').value=''; el('resultCard').style.display='none'; });
})();
</script>
</body>
</html>
