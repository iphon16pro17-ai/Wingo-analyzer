<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wingo Super Pro Analyzer (ржмрж╛ржВрж▓рж╛)</title>
<style>
  :root{--bg:#071026;--card:#0f1724;--muted:#94a3b8;--accent:#06b6d4;--good:#10b981;--bad:#fb7185;}
  body{font-family: "Noto Sans", "Noto Sans Bengali", system-ui, Arial; background:var(--bg); color:#e6eef8; margin:0; padding:16px;}
  .wrap{max-width:820px;margin:0 auto;}
  header{display:flex;align-items:center;gap:12px;margin-bottom:12px}
  h1{font-size:20px;margin:0;color:#7dd3fc}
  .card{background:var(--card);border-radius:12px;padding:14px;margin-bottom:12px;box-shadow:0 6px 24px rgba(2,6,23,.6)}
  label{color:var(--muted);font-size:13px}
  textarea{width:100%;min-height:110px;background:#061426;border:1px solid #1f2937;color:#e6eef8;padding:10px;border-radius:8px;font-size:15px;resize:vertical}
  input,select,button{font-size:15px}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .btn{background:var(--accent);color:#022; padding:9px 14px;border-radius:8px;border:none;cursor:pointer;font-weight:700}
  .btn.alt{background:#334155;color:#e6eef8}
  .out{background:#041226;padding:12px;border-radius:10px;margin-top:10px;color:#dbeafe}
  .badge{display:inline-block;padding:6px 8px;border-radius:8px;background:#071b2b;color:#c7f9ff;margin-right:6px;font-weight:700}
  .meter{height:12px;background:#0b1220;border-radius:999px;overflow:hidden;margin-top:6px}
  .meter > i{display:block;height:100%;background:linear-gradient(90deg,var(--good),var(--accent));width:0%}
  pre{white-space:pre-wrap;word-break:break-word}
  .small{color:var(--muted);font-size:13px}
  .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  @media(max-width:700px){ .grid{grid-template-columns:1fr} }
  .tbl{background:#071e2a;padding:8px;border-radius:8px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <header>
      <div>
        <h1>ЁЯОп Wingo Super Pro Analyzer (ржмрж╛ржВрж▓рж╛)</h1>
        <div class="small">0тАУ4 = SMALL | 5тАУ9 = BIG тАФ Pro level ржмрж┐рж╢рзНрж▓рзЗрж╖ржг (рж╢рзЗрж╖ 10тАУ100 рж░рзЗржХрж░рзНржб ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░ржмрзЗ)</div>
      </div>
    </header>

    <label>Numbers (ржХржорж╛/рж╕рзНржкрзЗрж╕/ржбржЯ ржпрзЗржнрж╛ржмрзЗржЗ ржЖржЫрзЗ ржмрж╕рж╛ржУ) тАФ рж╕рж░рзНржмрж╢рзЗрж╖ рж╕ржВржЦрзНржпрж╛ **ржПржХ рж▓рж╛ржЗржирзЗ** ржжрж┐ржи (10тАУ100):</label>
    <textarea id="nums" placeholder="ржЙржжрж╛рж╣рж░ржг: 5 8 3 6 0 0 5 2 5 5 6 0 3 7 0 8 2 5 8 1"></textarea>

    <div style="margin-top:8px" class="row">
      <button class="btn" id="analyze">ЁЯФО ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░рзЛ (Pro)</button>
      <button class="btn alt" id="clear">ЁЯз╣ ржХрзНрж▓рж┐рзЯрж╛рж░</button>
      <button class="btn alt" id="voiceToggle">ЁЯФК ржХржгрзНржа ржЖржЙржЯржкрзБржЯ: Off</button>
    </div>
    <div class="small" style="margin-top:8px">ржирзЛржЯ: ржпржд ржмрзЗрж╢рж┐ ржЗрждрж┐рж╣рж╛рж╕ (рзирзжтАУрзлрзж) ржжрзЗржмрзЗ, рждржд ржмрзЗрж╢рж┐ ржирж┐рж░рзНржнрж░ржпрзЛржЧрзНржп рж╣ржмрзЗред</div>
  </div>

  <div id="resultCard" class="card" style="display:none"></div>
</div>

<script>
(function(){
  const el = id=>document.getElementById(id);
  const btn = el('analyze'), clr = el('clear'), voiceBtn = el('voiceToggle');
  let speakOn = false;
  voiceBtn.addEventListener('click', ()=>{ speakOn = !speakOn; voiceBtn.textContent = speakOn? 'ЁЯФК ржХржгрзНржа ржЖржЙржЯржкрзБржЯ: On' : 'ЁЯФК ржХржгрзНржа ржЖржЙржЯржкрзБржЯ: Off'; });

  function parseInput(text){
    if(!text) return [];
    // normalize: replace dots, semicolons with commas, then split by non-digit
    const cleaned = text.replace(/[┘лред┬╖тАв┘А]/g,',').replace(/[^\d,]+/g,',');
    const parts = cleaned.split(',').map(s=>s.trim()).filter(s=>s!=='');
    const nums = parts.map(p=>{
      // allow multi-digit but only keep last digit (defensive)
      const m = p.match(/\d+$/);
      return m? parseInt(m[0].slice(-1),10) : null;
    }).filter(n=>n!==null && n>=0 && n<=9);
    return nums;
  }

  function classify(n){ return n>=5 ? 'BIG' : 'SMALL'; }

  function longestRun(types){
    if(types.length===0) return {type:null,len:0};
    let curr = types[0], curLen=1, bestType=curr, bestLen=1;
    for(let i=1;i<types.length;i++){
      if(types[i]===curr) curLen++; else { if(curLen>bestLen){bestLen=curLen;bestType=curr;} curr=types[i]; curLen=1; }
    }
    if(curLen>bestLen){bestLen=curLen;bestType=curr;}
    return {type:bestType,len:bestLen};
  }

  // pattern echo: return fraction 0..1 indicating how much last k-seq existed earlier
  function patternEcho(arr){
    if(arr.length < 6) return 0;
    const s = arr.join(',');
    const maxLen = Math.min(8, Math.floor(arr.length/2));
    let score = 0;
    for(let len=2; len<=maxLen; len++){
      const tail = arr.slice(-len).join(',');
      const idx = s.lastIndexOf(tail);
      if(idx !== -1 && idx < s.length - tail.length - 1){
        score += len / maxLen;
      }
    }
    return Math.min(1, score / 3);
  }

  // compute gap statistics for each digit (average gap between occurrences)
  function gapStats(arr){
    const lastIndex = {};
    const gaps = {}; for(let d=0; d<=9; d++){gaps[d]=[];}
    for(let i=0;i<arr.length;i++){
      const v = arr[i];
      if(lastIndex[v] !== undefined){
        gaps[v].push(i - lastIndex[v]);
      }
      lastIndex[v] = i;
    }
    const avgGap = {};
    for(let d=0; d<=9; d++){
      const g = gaps[d];
      avgGap[d] = g.length? (g.reduce((a,b)=>a+b,0)/g.length) : null;
    }
    return avgGap;
  }

  function analyzeSeries(nums){
    const total = nums.length;
    const types = nums.map(n=> classify(n));
    const bigCount = types.filter(t=>t==='BIG').length;
    const smallCount = total - bigCount;

    // windows
    const last3 = nums.slice(-3), last5 = nums.slice(-5), last10 = nums.slice(-10);
    const last3TypeBias = (last3.filter(n=>n>=5).length - (3 - last3.filter(n=>n>=5).length)) / 3; // -1..1
    const last5Bias = (last5.filter(n=>n>=5).length/last5.length);
    const last10Bias = (last10.filter(n=>n>=5).length/last10.length);

    const streak = (()=>{ // last contiguous same-size streak count
      if(types.length===0) return {type:null,len:0};
      let t = types[types.length-1], len=1;
      for(let i=types.length-2;i>=0;i--){
        if(types[i]===t) len++; else break;
      }
      return {type:t,len:len};
    })();

    const longest = longestRun(types);
    const echo = patternEcho(nums);
    const gaps = gapStats(nums);

    // Weighted scoring components (deterministic weights)
    // Each component returns score favoring BIG in 0..1 (0 => strong SMALL, 1 => strong BIG)
    const comp = {};

    // 1) Recent bias (last5) -> linear map [0..1]
    comp.recent = last5Bias; // 0..1

    // 2) Momentum (last3): map -1..1 -> 0..1
    comp.momentum = (last3TypeBias + 1) / 2;

    // 3) Streak reversal: if last streak is long for SMALL => favor BIG
    comp.streakRev = 0.5;
    if(streak.type === 'SMALL'){
      if(streak.len >= 7) comp.streakRev = 0.99;
      else if(streak.len >= 5) comp.streakRev = 0.92;
      else if(streak.len === 4) comp.streakRev = 0.80;
      else if(streak.len === 3) comp.streakRev = 0.58;
      else comp.streakRev = 0.45;
    } else if(streak.type === 'BIG'){
      // long big streak increases chance of small; so favor BIG low
      if(streak.len >= 7) comp.streakRev = 0.08;
      else if(streak.len >=5) comp.streakRev = 0.18;
      else if(streak.len === 4) comp.streakRev = 0.30;
      else if(streak.len === 3) comp.streakRev = 0.50;
      else comp.streakRev = 0.6;
    } else comp.streakRev = 0.5;

    // 4) Pattern echo: if recent pattern has been seen earlier, it favors continuation of that pattern.
    // We'll compute a direction from recent majority
    const recentMajority = (last5.filter(n=>n>=5).length >= 3) ? 1 : 0;
    comp.echo = echo * (recentMajority===1 ? 1.0 : 0.0); // only boost BIG if recent majority Big else 0

    // 5) Balance correction: overall bigRatio
    const overallBigRatio = bigCount / total;
    // Convert to favor BIG: if overallBigRatio low then favor BIG more for correction
    comp.balance = 1 - overallBigRatio; // if many small overall, comp.balance >0.5

    // 6) gap based: if certain digits are overdue (large avg gap) and they are BIG digits, increase BIG preference slightly
    let gapBoost = 0;
    const avgGaps = gaps;
    // compute top candidates overdue among big digits
    const bigDigits = [5,6,7,8,9];
    let overdueCount = 0, considered = 0;
    for(const d of bigDigits){
      if(avgGaps[d] === null) continue;
      considered++;
      if(avgGaps[d] >= 6) overdueCount++;
    }
    if(considered>0) gapBoost = Math.min(0.08, (overdueCount/considered)*0.08);
    comp.gap = 0.5 + gapBoost; // near 0.5 base

    // aggregate with weights
    // weights chosen deterministically
    const weights = {recent:0.26,momentum:0.18,streakRev:0.28,echo:0.12,balance:0.10,gap:0.06};
    const bigScore = (comp.recent*weights.recent + comp.momentum*weights.momentum + comp.streakRev*weights.streakRev + comp.echo*weights.echo + comp.balance*weights.balance + comp.gap*weights.gap);
    // normalize by sum of weights (which is 1.0)
    const bigPct = Math.round(bigScore*100);
    const smallPct = 100 - bigPct;

    // Confidence calculation: based on component strengths + streak length + echo
    const compMax = Math.max(Math.abs((comp.recent-0.5)*2), Math.abs((comp.momentum-0.5)*2), Math.abs((comp.streakRev-0.5)*2), comp.echo, Math.abs((comp.balance-0.5)*2));
    const confidence = Math.min(98, Math.round(45 + compMax*50 + (streak.len>2? Math.min(10, streak.len*2) : 0) + echo*5));

    // Top digit candidates by simple heuristic: frequency + recency boost
    const freq = {};
    for(let d=0; d<=9; d++) freq[d]=0;
    for(let i=0;i<nums.length;i++) freq[nums[i]]++;
    // candidate score = freq normalized + recency multiplier if in last 5
    const last5Set = new Set(last5);
    const cand = [];
    for(let d=0; d<=9; d++){
      let score = (freq[d]/Math.max(1,total)) * 0.6 + (last5Set.has(d)?0.4:0);
      cand.push({d,score});
    }
    cand.sort((a,b)=>b.score-a.score);
    const top3 = cand.slice(0,3).map(c=>c.d);

    return {
      total, bigCount, smallCount, last3, last5, last10,
      last5Bias, last10Bias, streak, longest, echo, avgGaps, bigPct, smallPct, confidence, top3, components: comp
    };
  }

  function prettyReport(nums, res){
    // build HTML
    const lastSeq = nums.slice(-Math.min(nums.length,50)).join(', ');
    const html = [];
    html.push('<div style="font-weight:700;font-size:16px;margin-bottom:6px">ЁЯФО ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржкрзНрж░рждрж┐ржмрзЗржжржи (Pro)</div>');
    html.push(`<div class="small">ржмрж┐рж╢рзНрж▓рзЗрж╖рж┐ржд рж╕ржВржЦрзНржпрж╛ (рж╢рзЗрж╖ ${res.total}): <b>${lastSeq}</b></div>`);
    html.push('<div style="margin-top:8px" class="tbl">');
    html.push(`<div>ЁЯУК рж╕рж╛ржорзНржкрзНрж░рждрж┐ржХ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг (last10): <b>${res.last10.join(', ')}</b></div>`);
    html.push(`<div style="margin-top:6px">BIG: <b>${res.bigCount}</b>  |  SMALL: <b>${res.smallCount}</b></div>`);
    html.push(`<div style="margin-top:6px">ЁЯФБ ржЯрж╛ржирж╛ рж╕рзНржЯрзНрж░рж┐ржХ: <b>${res.streak.type}</b> ├Ч <b>${res.streak.len}</b></div>`);
    html.push(`<div style="margin-top:6px">ЁЯУИ ржмрзЬрзЗрж░ рж╕ржорзНржнрж╛ржмрзНржпрждрж╛: <b style="color:${res.bigPct>res.smallPct? '#34d399':'#fb7185'}">${res.bigPct}%</b>  тАФ ржЫрзЛржЯ: ${res.smallPct}%</div>`);
    html.push(`<div style="margin-top:6px">ЁЯФР ржЖрждрзНржоржмрж┐рж╢рзНржмрж╛рж╕: <b>${res.confidence}%</b></div>`);
    html.push(`<div style="margin-top:8px">ЁЯз╛ ржЯрзНрж░рзЗржирзНржб ржЯрж╛ржЗржк: <b>${(res.components.streakRev>0.6? 'Reversal-biased' : (res.last5Bias>0.6? 'Momentum Big' : 'Mixed'))}</b></div>`);
    html.push(`<div style="margin-top:8px">ЁЯОп рж╕ржорзНржнрж╛ржмрзНржп рж╢рзАрж░рзНрж╖ ржиржорзНржмрж░ (Top 3): <b>${res.top3.join(', ')}</b> (Historical freq + recency)</div>`);
    html.push(`<div style="margin-top:8px">ЁЯФм ржкрзНржпрж╛ржЯрж╛рж░рзНржи ржЗржХрзЛ рж╕рзНржХрзЛрж░: <b>${(res.echo*100).toFixed(0)}%</b> (0 тЖТ ржирждрзБржи ржкрзНржпрж╛ржЯрж╛рж░рзНржи, 100 тЖТ ржЖржЧрзЗ ржжрзЗржЦрж╛ ржкрзНржпрж╛ржЯрж╛рж░рзНржи)</div>`);
    html.push('</div>');

    html.push('<div style="margin-top:10px">');
    html.push('<b>ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржХрж╛рж░ржг:</b>');
    html.push('<ul>');
    // reasons
    if(res.streak.len >= 4){
      html.push(`<li>рж╕рзНржЯрзНрж░рж┐ржХ ржбрж┐ржЯрзЗржХрж╢ржи: рж╢рзЗрж╖ ${res.streak.len} ржЯрж┐ ржзрж╛рж░рж╛ржмрж╛рж╣рж┐ржХ "${res.streak.type}" тАФ рж╕рзНржЯрзНрж░рж┐ржХ-рж░рж┐ржнрж╛рж░рзНрж╕ рж╕ржорзНржнрж╛ржмрзНржпрждрж╛ ржмрзГржжрзНржзрж┐ ржХрж░рзЗржЫрзЗред</li>`);
    } else {
      html.push(`<li>рж╕рзНржЯрзНрж░рж┐ржХ рж▓рзЗржи ржХржо: ${res.streak.len} тАФ рж╕рзНржЯрзНрж░рж┐ржХ ржПрж▓рж╛рж░рзНржо ржирзЗржЗред</li>`);
    }
    html.push(`<li>Recent bias (last 5) Big-ratio: ${(res.last5Bias*100).toFixed(0)}%</li>`);
    html.push(`<li>Momentum (last3): ${(res.components.momentum*100).toFixed(0)}% тЖТ positive favors BIG</li>`);
    html.push(`<li>Balance-correction factor: ${(res.components.balance*100).toFixed(0)}% (ржпржд ржХржо overall Big, рждржд ржмрзЗрж╢рзА correction favor Big)</li>`);
    html.push(`<li>Gap-based boost for overdue big digits: ${( (res.components.gap-0.5)*100 ).toFixed(1)}%</li>`);
    html.push('</ul>');
    html.push('</div>');

    html.push('<div style="margin-top:10px" class="small">тЪая╕П рж╕рзНржорж░ржгрзАрзЯ: ржПржЯрж┐ ржПржХржЯрж┐ ржкрж░рж┐рж╕ржВржЦрзНржпрж╛ржиржнрж┐рждрзНрждрж┐ржХ ржЖржирзБржорж╛ржирж┐ржХ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг тАФ ржмрж╛рж╕рзНрждржм ржлрж▓ ржкрзБрж░рзЛржЯрж╛ржЗ рж░тАНрзНржпрж╛ржирзНржбржо рж╣рждрзЗ ржкрж╛рж░рзЗред ржмрж╛ржЬрж┐ ржмрж╛ рж╕рж┐ржжрзНржзрж╛ржирзНржд ржирзЗрзЯрж╛рж░ ржЖржЧрзЗ ржирж┐ржЬрзЗржЗ ржмрж┐ржмрзЗржЪржирж╛ ржХрж░рзЛред</div>');
    return html.join('');
  }

  btn.addEventListener('click', ()=>{
    const raw = el('nums').value || '';
    const nums = parseInput(raw);
    const out = el('resultCard');
    if(nums.length < 6){ out.style.display='block'; out.innerHTML = `<div class="out"><b>рждрзНрж░рзБржЯрж┐:</b> ржХржоржкржХрзНрж╖рзЗ рзмржЯрж┐ рж╕ржВржЦрзНржпрж╛ ржкрзНрж░рзЯрзЛржЬржи (ржПржЦржи ржкрж╛ржУрзЯрж╛ ржЧрзЗржЫрзЗ ${nums.length})</div>`; return; }
    if(nums.length > 200) { out.style.display='block'; out.innerHTML = `<div class="out"><b>рждрзНрж░рзБржЯрж┐:</b> рж╕рж░рзНржмрзЛржЪрзНржЪ рзирзжрзж ржЗржиржкрзБржЯ рж╕ржорж░рзНржержи ржХрж░рзЗред</div>`; return; }

    const res = analyzeSeries(nums);
    out.style.display='block';
    out.innerHTML = prettyReport(nums, res);

    if(speakOn && 'speechSynthesis' in window){
      const txt = `ржкрж░ржмрж░рзНрждрзА рж╕ржорзНржнрж╛ржмрзНржп ржлрж▓: ${res.bigPct > res.smallPct ? 'ржмрзЬ' : 'ржЫрзЛржЯ'}, ржЖрждрзНржоржмрж┐рж╢рзНржмрж╛рж╕ ${res.confidence} рж╢рждрж╛ржВрж╢ред`;
      const msg = new SpeechSynthesisUtterance(txt);
      msg.lang = 'bn-BD';
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(msg);
    }
  });

  clr.addEventListener('click', ()=>{ el('nums').value=''; el('resultCard').style.display='none'; });
})();
</script>
</body>
</html>
